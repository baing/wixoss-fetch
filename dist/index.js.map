{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/tar-js/lib/header.js","node_modules/tar-js/lib/tar.js","node_modules/tar-js/lib/utils.js","src/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\t\n/*\nstruct posix_header {             // byte offset\n\tchar name[100];               //   0\n\tchar mode[8];                 // 100\n\tchar uid[8];                  // 108\n\tchar gid[8];                  // 116\n\tchar size[12];                // 124\n\tchar mtime[12];               // 136\n\tchar chksum[8];               // 148\n\tchar typeflag;                // 156\n\tchar linkname[100];           // 157\n\tchar magic[6];                // 257\n\tchar version[2];              // 263\n\tchar uname[32];               // 265\n\tchar gname[32];               // 297\n\tchar devmajor[8];             // 329\n\tchar devminor[8];             // 337\n\tchar prefix[155];             // 345\n                                  // 500\n};\n*/\n\n\tvar utils = require(\"./utils\"),\n\t\theaderFormat;\n\t\n\theaderFormat = [\n\t\t{\n\t\t\t'field': 'fileName',\n\t\t\t'length': 100\n\t\t},\n\t\t{\n\t\t\t'field': 'fileMode',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'uid',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'gid',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'fileSize',\n\t\t\t'length': 12\n\t\t},\n\t\t{\n\t\t\t'field': 'mtime',\n\t\t\t'length': 12\n\t\t},\n\t\t{\n\t\t\t'field': 'checksum',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'type',\n\t\t\t'length': 1\n\t\t},\n\t\t{\n\t\t\t'field': 'linkName',\n\t\t\t'length': 100\n\t\t},\n\t\t{\n\t\t\t'field': 'ustar',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'owner',\n\t\t\t'length': 32\n\t\t},\n\t\t{\n\t\t\t'field': 'group',\n\t\t\t'length': 32\n\t\t},\n\t\t{\n\t\t\t'field': 'majorNumber',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'minorNumber',\n\t\t\t'length': 8\n\t\t},\n\t\t{\n\t\t\t'field': 'filenamePrefix',\n\t\t\t'length': 155\n\t\t},\n\t\t{\n\t\t\t'field': 'padding',\n\t\t\t'length': 12\n\t\t}\n\t];\n\n\tfunction formatHeader(data, cb) {\n\t\tvar buffer = utils.clean(512),\n\t\t\toffset = 0;\n\n\t\theaderFormat.forEach(function (value) {\n\t\t\tvar str = data[value.field] || \"\",\n\t\t\t\ti, length;\n\n\t\t\tfor (i = 0, length = str.length; i < length; i += 1) {\n\t\t\t\tbuffer[offset] = str.charCodeAt(i);\n\t\t\t\toffset += 1;\n\t\t\t}\n\n\t\t\toffset += value.length - i; // space it out with nulls\n\t\t});\n\n\t\tif (typeof cb === 'function') {\n\t\t\treturn cb(buffer, offset);\n\t\t}\n\t\treturn buffer;\n\t}\n\t\n\tmodule.exports.structure = headerFormat;\n\tmodule.exports.format = formatHeader;\n}());\n","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\n\tvar header = require(\"./header\"),\n\t\tutils = require(\"./utils\"),\n\t\trecordSize = 512,\n\t\tblockSize;\n\t\n\tfunction Tar(recordsPerBlock) {\n\t\tthis.written = 0;\n\t\tblockSize = (recordsPerBlock || 20) * recordSize;\n\t\tthis.out = utils.clean(blockSize);\n\t}\n\n\tTar.prototype.append = function (filepath, input, opts, callback) {\n\t\tvar data,\n\t\t\tchecksum,\n\t\t\tmode,\n\t\t\tmtime,\n\t\t\tuid,\n\t\t\tgid,\n\t\t\theaderArr;\n\n\t\tif (typeof input === 'string') {\n\t\t\tinput = utils.stringToUint8(input);\n\t\t} else if (input.constructor !== Uint8Array.prototype.constructor) {\n\t\t\tthrow 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\\s*([$A-Za-z_][0-9A-Za-z_]*)\\s*\\(/)[1];\n\t\t}\n\n\t\tif (typeof opts === 'function') {\n\t\t\tcallback = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\topts = opts || {};\n\n\t\tmode = opts.mode || parseInt('777', 8) & 0xfff;\n\t\tmtime = opts.mtime || Math.floor(+new Date() / 1000);\n\t\tuid = opts.uid || 0;\n\t\tgid = opts.gid || 0;\n\n\t\tdata = {\n\t\t\tfileName: filepath,\n\t\t\tfileMode: utils.pad(mode, 7),\n\t\t\tuid: utils.pad(uid, 7),\n\t\t\tgid: utils.pad(gid, 7),\n\t\t\tfileSize: utils.pad(input.length, 11),\n\t\t\tmtime: utils.pad(mtime, 11),\n\t\t\tchecksum: '        ',\n\t\t\ttype: '0', // just a file\n\t\t\tustar: 'ustar  ',\n\t\t\towner: opts.owner || '',\n\t\t\tgroup: opts.group || ''\n\t\t};\n\n\t\t// calculate the checksum\n\t\tchecksum = 0;\n\t\tObject.keys(data).forEach(function (key) {\n\t\t\tvar i, value = data[key], length;\n\n\t\t\tfor (i = 0, length = value.length; i < length; i += 1) {\n\t\t\t\tchecksum += value.charCodeAt(i);\n\t\t\t}\n\t\t});\n\n\t\tdata.checksum = utils.pad(checksum, 6) + \"\\u0000 \";\n\n\t\theaderArr = header.format(data);\n\n\t\tvar i, offset, length;\n\n\t\tthis.out.set(headerArr, this.written);\n\n\t\tthis.written += headerArr.length;\n\n\t\t// If there is not enough space in this.out, we need to expand it to\n\t\t// fit the new input.\n\t\tif (this.written + input.length > this.out.length) {\n\t\t\tthis.out = utils.extend(this.out, this.written, input.length, blockSize);\n\t\t}\n\n\t\tthis.out.set(input, this.written);\n\n\t\t// to the nearest multiple of recordSize\n\t\tthis.written += input.length + (recordSize - (input.length % recordSize || recordSize));\n\n\t\t// make sure there's at least 2 empty records worth of extra space\n\t\tif (this.out.length - this.written < recordSize * 2) {\n\t\t\tthis.out = utils.extend(this.out, this.written, recordSize * 2, blockSize);\n\t\t}\n\n\t\tif (typeof callback === 'function') {\n\t\t\tcallback(this.out);\n\t\t}\n\n\t\treturn this.out;\n\t};\n\n\tTar.prototype.clear = function () {\n\t\tthis.written = 0;\n\t\tthis.out = utils.clean(blockSize);\n\t};\n\n  Tar.utils = utils;\n\n\tTar.stringToUint8 = utils.stringToUint8;\n\tTar.uint8ToBase64 = utils.uint8ToBase64;\n  Tar.base64ToUint8 = utils.base64ToUint8;\n\t\n\tmodule.exports = Tar;\n}());\n","/*\n * tar-js\n * MIT (c) 2011 T. Jameson Little\n */\n\n(function () {\n\t\"use strict\";\n\n\tvar lookup = [\n\t\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n\t\t\t'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n\t\t\t'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n\t\t\t'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n\t\t\t'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n\t\t\t'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n\t\t\t'w', 'x', 'y', 'z', '0', '1', '2', '3',\n\t\t\t'4', '5', '6', '7', '8', '9', '+', '/'\n\t\t];\n\tfunction clean(length) {\n\t\tvar i, buffer = new Uint8Array(length);\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tbuffer[i] = 0;\n\t\t}\n\t\treturn buffer;\n\t}\n\n\tfunction extend(orig, length, addLength, multipleOf) {\n\t\tvar newSize = length + addLength,\n\t\t\tbuffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);\n\n\t\tbuffer.set(orig);\n\n\t\treturn buffer;\n\t}\n\n\tfunction pad(num, bytes, base) {\n\t\tnum = num.toString(base || 8);\n\t\treturn \"000000000000\".substr(num.length + 12 - bytes) + num;\n\t}\t\n\t\n\tfunction stringToUint8 (input, out, offset) {\n\t\tvar i, length;\n\n\t\tout = out || clean(input.length);\n\n\t\toffset = offset || 0;\n\t\tfor (i = 0, length = input.length; i < length; i += 1) {\n\t\t\tout[offset] = input.charCodeAt(i);\n\t\t\toffset += 1;\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// this prevents an ERR_INVALID_URL in Chrome (Firefox okay)\n\t\tswitch (output.length % 4) {\n\t\t\tcase 1:\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tfunction base64ToUint8(input) {\n\t\tvar base64 = input.match(/^([^=]+)/)[1],\n\t\t\textraBytes = input.match(/(=*)$/)[1].length,\n\t\t\ti = 0, length = base64.length, temp, offset = 0,\n\t\t\tret = clean(base64.length * .75 + extraBytes);\n\n\t\twhile (i < length) {\n\t\t\ttemp = 0;\n\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 18;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 12;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A') << 6;\n\t\t\ti += 1;\n\t\t\ttemp |= lookup.indexOf(base64.charAt(i) || 'A');\n\t\t\ti += 1;\n\n\t\t\tret[offset] = temp >> 16 & 0xFF;\n\t\t\toffset += 1;\n\t\t\tret[offset] = temp >> 8 & 0xFF;\n\t\t\toffset += 1;\n\t\t\tret[offset] = temp & 0xFF;\n\t\t\toffset += 1;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tmodule.exports.clean = clean;\n\tmodule.exports.pad = pad;\n\tmodule.exports.extend = extend;\n\tmodule.exports.stringToUint8 = stringToUint8;\n\tmodule.exports.uint8ToBase64 = uint8ToBase64;\n\tmodule.exports.base64ToUint8 = base64ToUint8;\n}());\n","'use strict'\n\nconst domain = 'www.takaratomy.co.jp'\nconst Tar = require('tar-js')\n\n/* utils */\nconst toArr = obj => {\n\tif (!obj) return []\n\tif (typeof obj === 'string') return []\n\treturn Array.prototype.slice.call(obj,0)\n}\nconst $fetch = (...arg) => {\n  return fetch(arg).then(res => {\n    if (res.ok) return res\n    return Promise.reject(res)\n  })\n}\nconst stringToUint8 = str => {\n  return (new TextEncoder()).encode(str)\n}\n\n/* parser */\nfunction toCardType(str) {\n\tlet map = {\n\t\t'ルリグ': 'LRIG',\n\t\t'アーツ': 'ARTS',\n\t\t'シグニ': 'SIGNI',\n\t\t'スペル': 'SPELL',\n\t}\n\treturn map[str] || str\n}\nfunction toColor(str) {\n\tlet map = {\n\t\t'白': 'WHITE',\n\t\t'黒': 'BLACK',\n\t\t'赤': 'RED',\n\t\t'青': 'BLUE',\n\t\t'緑': 'GREEN',\n\t\t'無': 'COLORLESS',\n\t}\n\treturn map[str] || str\n}\nfunction toCardText(el) {\n  let text = toArr(el.childNodes).map(node => {\n    if (node.nodeType === node.TEXT_NODE) {\n      return node.nodeValue.replace(/^\\s+/,'').replace(/\\s+$/,'')\n    }\n    if (node.nodeName === 'IMG') {\n      return '【' + node.alt + '】'\n    }\n    if (node.nodeName === 'BR') {\n      return '\\n'\n    }\n    return node.textContent\n  }).join('')\n}\nfunction toFaq(el) {\n\tlet faq = {}\n\tfaq.q = el.querySelector('.card_ruleFAQ_q').textContent.replace(/^\\s+/,'').replace(/\\s+$/,'')\n\tfaq.a = el.querySelector('.card_ruleFAQ_a').textContent.replace(/^\\s+/,'').replace(/\\s+$/,'')\n\treturn faq\n}\n\n\nfunction toInfo(doc, id) {\n\tlet info = {}\n\tinfo.pid = id\n\tinfo.timestamp = Date.now()\n\tinfo.wxid = doc.querySelector('.card_detail_title > p').textContent\n\tinfo.name = doc.querySelector('.card_detail_title > h3').firstChild.textContent\n\tinfo.kana = doc.querySelector('.card_detail_kana').textContent.slice(1,-1)\n\tinfo.rarity = doc.querySelector('.card_rarity').textContent.replace(/\\s/g,'')\n\n\tlet trs = doc.querySelectorAll('.card_date_box tr')\n\t// info.cardType = toCardType(trs[0].children[1].textContent)\n\tinfo.cardType = trs[0].children[1].textContent\n\tinfo.class = trs[0].children[3].textContent\n\t// info.color = toColor(trs[1].children[1].textContent)\n\tinfo.color = trs[1].children[1].textContent\n\tinfo.level = trs[1].children[3].textContent\n\tinfo.growCost = trs[2].children[1].textContent\n\tinfo.cost = trs[2].children[3].textContent\n\tinfo.limit = trs[3].children[1].textContent\n\tinfo.power = trs[3].children[3].textContent\n\tinfo.limiting = trs[4].children[1].textContent\n\tinfo.guard = trs[4].children[3].textContent\n\n\tlet el = doc.querySelector('.card_skill')\n\tinfo.cardSkill = el? toCardText(el) : ''\n\n\tinfo.cardTexts = toArr(doc.querySelectorAll('.card_text:not(.card_skill)')).map(toCardText)\n\n\t// info.imgUrl = domain + doc.querySelector('.card_img > img').getAttribute('src')\n\tinfo.imgUrl = doc.querySelector('.card_img > img').getAttribute('src')\n\tinfo.illust = doc.querySelector('.card_img').textContent.match(/Illust (.*)$/)[1]\n\n\tinfo.faqs = toArr(doc.querySelectorAll('.card_FAQ > p')).map(toFaq)\n\n\treturn info\n}\n\n/* fetch */\nfunction fetchById (tar, i) {\n  let url = `http://${domain}/products/wixoss/card/card_detail.php?card_id=${i}`\n  return $fetch(url)\n  .then(res => res.text())\n  .then(html => {\n    let dom = (new DOMParser()).parseFromString(html,'text/html')\n    if (!dom) throw 'Failed to parse DOM!'\n\n    // json\n    let info = toInfo(dom, i)\n    let json = JSON.stringify(info, null, '\\t')\n    let name = ('000' + i).slice(-4) + '_' + info.wxid\n    tar.append(`${name}.json`, stringToUint8(json))\n    console.log(`${name}.json done!`)\n\n    // html\n    html = html.replace('<head>','<head>\\r\\n<base href=\"http://www.takaratomy.co.jp/\" />')\n    tar.append(`${name}.html`, stringToUint8(html))\n    console.log(`${name}.html done!`)\n\n    // image\n    return $fetch(info.imgUrl)\n    .then(res => res.arrayBuffer())\n    .then(buffer => {\n      tar.append(`${name}.jpg`, new Uint8Array(buffer))\n      console.log(`${name}.jpg done!`)\n    })\n  })\n}\n\nfunction fetchRange(min, max) {\n  let tar = new Tar()\n  let promises = []\n  for (let i = min; i <= max; i++) {\n    promises.push(fetchById(tar, i))\n  }\n  return Promise.all(promises)\n  .then(() => {\n    let name = ('000' + min).slice(-4) + '-' + ('000' + max).slice(-4)\n    downloadTar(tar, name)\n  })\n}\n\nfunction downloadTar(tar, name) {\n  let blob = new Blob([tar.out], { type: 'application/octet-stream' })\n  let url = URL.createObjectURL(blob)\n  let link = document.createElement('a')\n  link.href = url\n  link.download = `${name}.tar`\n  link.click()\n}\n\nwindow.fetchRange = fetchRange\n"]}